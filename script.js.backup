            if (wordCount < 50) {
                score -= 15;
                improvements.push('ì¡°ì‚¬ ë‚´ìš©ì„ ë” ìƒì„¸íˆ ê¸°ë¡ í•„ìš”');
            }
            break;
            
        case 4: // ì¡°ì§ ë° ì •ë¦¬í•˜ê¸°
            if (content.includes('ë¶„ë¥˜') || content.includes('ì •ë¦¬') || content.includes('êµ¬ì¡°')) {
                score += 15;
                strengths.push('ì²´ê³„ì ì¸ ì •ë³´ ì •ë¦¬');
            }
            if (content.includes('ê´€ê³„') || content.includes('íŒ¨í„´') || content.includes('ì—°ê²°')) {
                score += 10;
                strengths.push('ì •ë³´ ê°„ ê´€ê³„ ë¶„ì„');
            }
            if (sentenceCount < 3) {
                score -= 10;
                improvements.push('ë” ì²´ê³„ì ì¸ êµ¬ì¡°í™” í•„ìš”');
            }
            break;
            
        case 5: // ì¼ë°˜í™”í•˜ê¸°
            if (content.includes('ì›ë¦¬') || content.includes('ë²•ì¹™') || content.includes('ì¼ë°˜ì ')) {
                score += 15;
                strengths.push('ì¼ë°˜ì  ì›ë¦¬ ë„ì¶œ');
            }
            if (content.includes('ì ìš©') || content.includes('í™•ì¥') || content.includes('í™œìš©')) {
                score += 10;
                strengths.push('í™•ì¥ ì ìš© ê°€ëŠ¥ì„± ì œì‹œ');
            }
            if (wordCount < 30) {
                score -= 15;
                improvements.push('ì¼ë°˜í™” ê³¼ì •ì„ ë” êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª… í•„ìš”');
            }
            break;
            
        case 6: // ì „ì´í•˜ê¸°
            if (content.includes('ì‹¤ìƒí™œ') || content.includes('ì ìš©') || content.includes('í™œìš©')) {
                score += 15;
                strengths.push('ì‹¤ìƒí™œ ì—°ê´€ì„± ì œì‹œ');
            }
            if (content.includes('ìƒˆë¡œìš´') || content.includes('ì°½ì˜ì ') || content.includes('ë‹¤ë¥¸')) {
                score += 10;
                strengths.push('ì°½ì˜ì  ì ìš© ì‹œë„');
            }
            if (!content.includes('ì ìš©') && !content.includes('í™œìš©')) {
                score -= 15;
                improvements.push('êµ¬ì²´ì ì¸ ì ìš© ë°©ì•ˆ ì œì‹œ í•„ìš”');
            }
            break;
    }

    // ì ìˆ˜ ë²”ìœ„ ì¡°ì •
    score = Math.max(0, Math.min(100, score));

    // ë ˆë²¨ ê²°ì •
    if (score >= 85) {
        level = 'ìƒ';
        feedback = `${criteria.ìƒ.description} ìˆ˜ì¤€ì˜ ìš°ìˆ˜í•œ ë‹µë³€ì…ë‹ˆë‹¤.`;
    } else if (score >= 65) {
        level = 'ì¤‘';
        feedback = `${criteria.ì¤‘.description} ìˆ˜ì¤€ì˜ ì–‘í˜¸í•œ ë‹µë³€ì…ë‹ˆë‹¤.`;
    } else {
        level = 'í•˜';
        feedback = `${criteria.í•˜.description} ìˆ˜ì¤€ìœ¼ë¡œ ë³´ì™„ì´ í•„ìš”í•©ë‹ˆë‹¤.`;
    }

    if (strengths.length === 0) {
        strengths.push('ì„±ì‹¤í•˜ê²Œ ì‘ì„±í•˜ë ¤ëŠ” ë…¸ë ¥ì´ ë³´ì…ë‹ˆë‹¤.');
    }
    
    if (improvements.length === 0) {
        improvements.push('ë” êµ¬ì²´ì ì´ê³  ìì„¸í•œ ì„¤ëª…ì„ ì¶”ê°€í•´ë³´ì„¸ìš”.');
    }

    return { score, level, strengths, improvements, feedback };
}

// ì‹¤ì‹œê°„ ì˜ë„ ì¼ì¹˜ë„ ê³„ì‚° (í…ìŠ¤íŠ¸ ê¸°ë°˜)
function calculateRealTimeIntentMatch() {
    if (!initialIntent) return 0;
    
    let totalMatch = 0;
    let completedStages = 0;
    
    // ì™„ë£Œëœ ê° ë‹¨ê³„ì˜ ì…ë ¥ ë‚´ìš©ê³¼ ì´ˆê¸° ì˜ë„ ë¹„êµ
    for (let stage = 1; stage <= 6; stage++) {
        const inputElement = document.getElementById(`stage${stage}Input`);
        if (inputElement && inputElement.value.trim()) {
            const stageMatch = calculateTextSimilarity(initialIntent, inputElement.value.trim());
            totalMatch += stageMatch;
            completedStages++;
        }
    }
    
    if (completedStages === 0) return 0;
    
    return Math.round(totalMatch / completedStages);
}

// í…ìŠ¤íŠ¸ ìœ ì‚¬ë„ ê³„ì‚° (ê°œì„ ëœ ì•Œê³ ë¦¬ì¦˜)
function calculateTextSimilarity(intent, input) {
    if (!intent || !input) return 0;
    
    // ë¬´ì˜ë¯¸í•œ ì…ë ¥ ê²€ì¦ ì¶”ê°€
    const trimmedInput = input.trim();
    const isOnlyNumbers = /^\d+$/.test(trimmedInput);
    const isRepeatedChars = /^(.)\1{2,}$/.test(trimmedInput);
    const isMeaningless = trimmedInput.length < 5 || 
                         /^[^ê°€-í£a-zA-Z]*$/.test(trimmedInput) ||
                         ['test', 'ã…ã„´ã…‡ã„¹', 'asdf', 'qwer', '123', '1234', 'abc'].includes(trimmedInput.toLowerCase());
    
    if (isOnlyNumbers || isRepeatedChars || isMeaningless) {
        console.log('âš ï¸ ë¬´ì˜ë¯¸í•œ ì…ë ¥ìœ¼ë¡œ ë‚®ì€ ìœ ì‚¬ë„ ë°˜í™˜:', trimmedInput);
        return 15; // ë§¤ìš° ë‚®ì€ ì ìˆ˜ ë°˜í™˜
    }
    
    // 1. í‚¤ì›Œë“œ ë§¤ì¹­ (40%)
    const intentKeywords = extractKeywords(intent);
    const inputKeywords = extractKeywords(input);
    
    let keywordMatches = 0;
    intentKeywords.forEach(keyword => {
        if (inputKeywords.some(inputKeyword => 
            inputKeyword.includes(keyword) || keyword.includes(inputKeyword) ||
            getSimilarity(keyword, inputKeyword) > 0.7
        )) {
            keywordMatches++;
        }
    });
    
    const keywordScore = intentKeywords.length > 0 ? 
        (keywordMatches / intentKeywords.length) * 40 : 0;
    
    // 2. ì˜ë¯¸ì  ì—°ê´€ì„± (40%)
    const semanticScore = calculateSemanticSimilarity(intent, input) * 40;
    
    // 3. ê¸¸ì´ ë° êµ¬ì¡° ìœ ì‚¬ë„ (20%)
    const structureScore = calculateStructureSimilarity(intent, input) * 20;
    
    return Math.min(100, keywordScore + semanticScore + structureScore);
}

// í‚¤ì›Œë“œ ì¶”ì¶œ (ë¶ˆìš©ì–´ ì œê±°)
function extractKeywords(text) {
    const stopWords = ['ì€', 'ëŠ”', 'ì´', 'ê°€', 'ì„', 'ë¥¼', 'ì—', 'ì—ì„œ', 'ì™€', 'ê³¼', 'ì˜', 'ë¡œ', 'ìœ¼ë¡œ', 'í•œ', 'í•˜ëŠ”', 'í•˜ë‹¤', 'ìˆë‹¤', 'ì—†ë‹¤', 'ê·¸', 'ì €', 'ì´ëŸ°', 'ì €ëŸ°', 'ë“±'];
    
    // ë¬´ì˜ë¯¸í•œ ì…ë ¥ ì²´í¬
    const trimmedText = text.trim();
    if (/^\d+$/.test(trimmedText) || trimmedText.length < 3) {
        return []; // ë¹ˆ ë°°ì—´ ë°˜í™˜ìœ¼ë¡œ í‚¤ì›Œë“œ ë§¤ì¹­ ì‹¤íŒ¨
    }
    
    return text.toLowerCase()
        .replace(/[^\w\sê°€-í£]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 1 && !stopWords.includes(word) && !/^\d+$/.test(word))
        .slice(0, 10); // ìƒìœ„ 10ê°œ í‚¤ì›Œë“œë§Œ ì‚¬ìš©
}

// ë¬¸ìì—´ ìœ ì‚¬ë„ ê³„ì‚° (í¸ì§‘ ê±°ë¦¬ ê¸°ë°˜)
function getSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const editDistance = getEditDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
}

// í¸ì§‘ ê±°ë¦¬ ê³„ì‚°
function getEditDistance(str1, str2) {
    const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
    
    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
    
    for (let j = 1; j <= str2.length; j++) {
        for (let i = 1; i <= str1.length; i++) {
            if (str1[i - 1] === str2[j - 1]) {
                matrix[j][i] = matrix[j - 1][i - 1];
            } else {
                matrix[j][i] = Math.min(
                    matrix[j - 1][i - 1] + 1,
                    matrix[j][i - 1] + 1,
                    matrix[j - 1][i] + 1
                );
            }
        }
    }
    
    return matrix[str2.length][str1.length];
}

// ì˜ë¯¸ì  ìœ ì‚¬ë„ ê³„ì‚° (ê°„ë‹¨í•œ íœ´ë¦¬ìŠ¤í‹±)
function calculateSemanticSimilarity(intent, input) {
    // ì£¼ì œ ê´€ë ¨ í‚¤ì›Œë“œ ê·¸ë£¹
    const topicGroups = [
        ['ê³¼í•™', 'ì‹¤í—˜', 'ê´€ì°°', 'ë¶„ì„', 'ì—°êµ¬', 'ì¡°ì‚¬'],
        ['ì—­ì‚¬', 'ë¬¸í™”', 'ì‚¬íšŒ', 'ì¸ë¬¼', 'ì‹œëŒ€', 'ë°°ê²½'],
        ['ë¬¸í•™', 'ì‘í’ˆ', 'ì‘ê°€', 'ì‹œ', 'ì†Œì„¤', 'í‘œí˜„'],
        ['ìˆ˜í•™', 'ê³„ì‚°', 'ê³µì‹', 'ë¬¸ì œ', 'í•´ê²°', 'ë…¼ë¦¬'],
        ['ì˜ˆìˆ ', 'ìŒì•…', 'ë¯¸ìˆ ', 'ì°½ì‘', 'í‘œí˜„', 'ê°ìƒ']
    ];
    
    const intentTopics = getTopicMatch(intent, topicGroups);
    const inputTopics = getTopicMatch(input, topicGroups);
    
    let commonTopics = 0;
    intentTopics.forEach(topic => {
        if (inputTopics.includes(topic)) commonTopics++;
    });
    
    return intentTopics.length > 0 ? commonTopics / intentTopics.length : 0;
}

// ì£¼ì œ ë§¤ì¹­
function getTopicMatch(text, topicGroups) {
    const matches = [];
    const lowerText = text.toLowerCase();
    
    topicGroups.forEach((group, index) => {
        if (group.some(keyword => lowerText.includes(keyword))) {
            matches.push(index);
        }
    });
    
    return matches;
}

// êµ¬ì¡°ì  ìœ ì‚¬ë„ ê³„ì‚°
function calculateStructureSimilarity(intent, input) {
    const intentLength = intent.length;
    const inputLength = input.length;
    
    // ê¸¸ì´ ìœ ì‚¬ë„
    const lengthRatio = Math.min(intentLength, inputLength) / Math.max(intentLength, inputLength);
    
    // ë¬¸ì¥ êµ¬ì¡° ìœ ì‚¬ë„ (ê°„ë‹¨í•œ ë²„ì „)
    const intentSentences = intent.split(/[.!?]/);
    const inputSentences = input.split(/[.!?]/);
    
    const sentenceRatio = Math.min(intentSentences.length, inputSentences.length) / 
                         Math.max(intentSentences.length, inputSentences.length);
    
    return (lengthRatio + sentenceRatio) / 2;
}

// ì‹¤ì‹œê°„ ì˜ë„ ì¼ì¹˜ë„ ì—…ë°ì´íŠ¸ (ìˆ˜ì •ëœ ë²„ì „)
function updateRealTimeIntentMatch() {
    const intentMatchElement = document.getElementById('intentMatch');
    
    if (intentMatchElement) {
        const realTimeMatch = calculateRealTimeIntentMatch();
        intentMatchElement.textContent = `${realTimeMatch}%`;
        
        // ìƒ‰ìƒ ì—…ë°ì´íŠ¸
        if (realTimeMatch >= 80) {
            intentMatchElement.style.color = '#28a745'; // ë…¹ìƒ‰
        } else if (realTimeMatch >= 60) {
            intentMatchElement.style.color = '#ffc107'; // ë…¸ë€ìƒ‰  
        } else {
            intentMatchElement.style.color = '#dc3545'; // ë¹¨ê°„ìƒ‰
        }
    }
}

// ìµœì¢… í‰ê°€ìš© ì˜ë„ ì¼ì¹˜ë„ (20% ë°˜ì˜)
function calculateFinalIntentScore() {
    if (!initialIntent) return 0;
    
    let totalIntentScore = 0;
    let stageCount = 0;
    
    // ê° ë‹¨ê³„ë³„ ì˜ë„ ì—°ê´€ì„± ì ìˆ˜ ê³„ì‚°
    for (let stage = 1; stage <= 6; stage++) {
        const inputElement = document.getElementById(`stage${stage}Input`);
        if (inputElement && inputElement.value.trim()) {
            const stageIntentScore = calculateAdvancedIntentMatch(
                initialIntent, 
                inputElement.value.trim(), 
                stage
            );
            totalIntentScore += stageIntentScore;
            stageCount++;
        }
    }
    
    return stageCount > 0 ? Math.round(totalIntentScore / stageCount) : 0;
}

// ê³ ê¸‰ ì˜ë„ ì¼ì¹˜ë„ ë¶„ì„ (ìµœì¢… í‰ê°€ìš©)
function calculateAdvancedIntentMatch(intent, input, stage) {
    // ë‹¨ê³„ë³„ ê°€ì¤‘ì¹˜ ì ìš©
    const stageWeights = {
        1: 1.2, // ê´€ê³„ë§ºê¸° - ì˜ë„ ì„¤ì •ì˜ ê¸°ì´ˆ
        2: 1.3, // ì§‘ì¤‘í•˜ê¸° - ì˜ë„ì˜ êµ¬ì²´í™”
        3: 1.0, // ì¡°ì‚¬í•˜ê¸° - ì¼ë°˜ì  ê°€ì¤‘ì¹˜
        4: 1.0, // ì¡°ì§ ë° ì •ë¦¬í•˜ê¸° - ì¼ë°˜ì  ê°€ì¤‘ì¹˜
        5: 1.1, // ì¼ë°˜í™”í•˜ê¸° - ì˜ë„ì™€ì˜ ì—°ê²°ì„± ì¤‘ìš”
        6: 1.2  // ì „ì´í•˜ê¸° - ì˜ë„ì˜ í™•ì¥ ì ìš©
    };
    
    const baseSimilarity = calculateTextSimilarity(intent, input);
    const weightedScore = baseSimilarity * (stageWeights[stage] || 1.0);
    
    return Math.min(100, weightedScore);
}

// ìµœì¢… ì¢…í•© ì ìˆ˜ ê³„ì‚°
function calculateFinalScore(contentScore, reflectionScore) {
    const intentScore = calculateFinalIntentScore();
    
    // ê°€ì¤‘ì¹˜ ì ìš©: ë‚´ìš© 70% + ì˜ë„ 20% + ì„±ì°° 10%
    const finalScore = Math.round(
        (contentScore * 0.7) + 
        (intentScore * 0.2) + 
        (reflectionScore * 0.1)
    );
    
    // ë“±ê¸‰ ê³„ì‚°
    let grade;
    if (finalScore >= 90) {
        grade = 'ìƒ';
    } else if (finalScore >= 70) {
        grade = 'ì¤‘';
    } else {
        grade = 'í•˜';
    }
    
    return {
        contentScore: Math.round(contentScore),
        intentScore: Math.round(intentScore),
        reflectionScore: Math.round(reflectionScore),
        finalScore: finalScore,
        grade: grade
    };
}

// ì…ë ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸)
function addRealTimeIntentListeners() {
    for (let stage = 1; stage <= 6; stage++) {
        const inputElement = document.getElementById(`stage${stage}Input`);
        if (inputElement) {
            inputElement.addEventListener('input', debounce(updateRealTimeIntentMatch, 500));
        }
    }
}

// ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜ (ì„±ëŠ¥ ìµœì í™”)
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// í‰ê°€ ê²°ê³¼ í‘œì‹œ ëª¨ë‹¬
function showEvaluationResult(stageNumber, evaluation) {
    console.log('ğŸ“Š í‰ê°€ ê²°ê³¼ í‘œì‹œ:', { stageNumber, evaluation });
    
    const stageNames = {
        1: 'ê´€ê³„ë§ºê¸°', 2: 'ì§‘ì¤‘í•˜ê¸°', 3: 'ì¡°ì‚¬í•˜ê¸°',
        4: 'ì¡°ì§ ë° ì •ë¦¬í•˜ê¸°', 5: 'ì¼ë°˜í™”í•˜ê¸°', 6: 'ì „ì´í•˜ê¸°'
    };
    
    const stageName = stageNames[stageNumber];
    const intentMatch = calculateRealTimeIntentMatch();
    
    console.log('ğŸ¯ ì˜ë„ ì¼ì¹˜ë„:', intentMatch);
    
    const modalHTML = `
        <div class="modal-overlay" id="evaluationModal">
            <div class="modal-content evaluation-result">
                <div class="evaluation-header">
                    <h3>${stageName} í‰ê°€ ê²°ê³¼</h3>
                    <button class="close-btn" onclick="closeEvaluationModal()">&times;</button>
                </div>
                <div class="evaluation-body">
                    <div class="score-display">
                        <div class="score-box ${evaluation.level}">
                            <div class="score-number">${evaluation.score}ì </div>
                            <div class="score-separator">:</div>
                            <div class="score-label">${evaluation.level}</div>
                        </div>
                    </div>
                    
                    <div class="evaluation-details">
                        <div class="feedback-section">
                            <h4>ğŸ“ í‰ê°€ í”¼ë“œë°±</h4>
                            <p>${evaluation.feedback}</p>
                        </div>
                        
                        <div class="strengths-section">
                            <h4>âœ… ì˜í•œ ì </h4>
                            <p>${evaluation.strengths.join(', ')}</p>
                        </div>
                        
                        <div class="improvements-section">
                            <h4>ğŸ’¡ ê°œì„ í•  ì </h4>
                            <p>${evaluation.improvements.join(', ')}</p>
                        </div>
                        
                        <div class="intent-match-section">
                            <h4>ğŸ¯ ì˜ë„ ì¼ì¹˜ë„</h4>
                            <div class="intent-match-bar">
                                <div class="intent-match-fill" style="width: ${intentMatch}%"></div>
                                <div class="intent-match-text">${intentMatch}%</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="evaluation-footer">
                    <button class="btn btn-primary" onclick="closeEvaluationModal()">í™•ì¸</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
    setTimeout(() => {
        document.getElementById('evaluationModal').classList.add('show');
    }, 10);
}

// í‰ê°€ ê²°ê³¼ ëª¨ë‹¬ ë‹«ê¸°
function closeEvaluationModal() {
    const modal = document.getElementById('evaluationModal');
    if (modal) {
        modal.classList.add('hiding');
        setTimeout(() => {
            modal.remove();
        }, 300);
    }
}

// ì„±ì°° ì°¸ì—¬ë„ ê³„ì‚°
function calculateReflectionScore() {
    let totalReflections = 0;
    let completedReflections = 0;
    
    // ê° ë‹¨ê³„ë³„ ì„±ì°° ì²´í¬ë°•ìŠ¤ ìƒíƒœ í™•ì¸
    for (let stage = 1; stage <= 6; stage++) {
        const checkboxes = document.querySelectorAll(`input[data-stage="${stage}"].reflection-checkbox`);
        totalReflections += checkboxes.length;
        
        checkboxes.forEach(checkbox => {
            if (checkbox.checked) {
                completedReflections++;
            }
        });
    }
    
    return totalReflections > 0 ? Math.round((completedReflections / totalReflections) * 100) : 0;
}

// ì „ì²´ íƒêµ¬ ì™„ë£Œ ì‹œ ìµœì¢… ì ìˆ˜ ê³„ì‚° ë° í‘œì‹œ
function showFinalScoreReport() {
    // ë‚´ìš© ì ìˆ˜ ê³„ì‚° (ê° ë‹¨ê³„ ì ìˆ˜ì˜ í‰ê· )
    let totalContentScore = 0;
    let completedStages = 0;
    
    for (let stage = 1; stage <= 6; stage++) {
        if (stageScores[stage] > 0) {
            totalContentScore += stageScores[stage];
            completedStages++;
        }
    }
    
    const contentScore = completedStages > 0 ? Math.round(totalContentScore / completedStages) : 0;
    const reflectionScore = calculateReflectionScore();
    
    // ìµœì¢… ì ìˆ˜ ê³„ì‚° (ë‚´ìš© 70% + ì˜ë„ 20% + ì„±ì°° 10%)
    const finalScoreData = calculateFinalScore(contentScore, reflectionScore);
    
    // ìµœì¢… ì ìˆ˜ ë°ì´í„° ì €ì¥
    window.finalScoreData = finalScoreData;
    
    console.log('ìµœì¢… ì ìˆ˜ ê³„ì‚° ê²°ê³¼:', finalScoreData);
    
    // ì™„ë£Œ ë©”ì‹œì§€ì™€ í•¨ê»˜ ìµœì¢… ì ìˆ˜ í‘œì‹œ
    showCompletionMessage(finalScoreData);
}

// í•™ìƒìš© ìµœì¢… ê²°ê³¼ ë³´ê³ ì„œ í‘œì‹œ (ì ìˆ˜ì™€ ê°œì„ ì‚¬í•­ í¬í•¨)
function showStudentFinalResult() {
    // ë‚´ìš© ì ìˆ˜ ê³„ì‚°
    let totalContentScore = 0;
    let completedStages = 0;
    
    for (let stage = 1; stage <= 6; stage++) {
        if (stageScores[stage] > 0) {
            totalContentScore += stageScores[stage];
            completedStages++;
        }
    }
    
    const contentScore = completedStages > 0 ? Math.round(totalContentScore / completedStages) : 0;
    const reflectionScore = calculateReflectionScore();
    const finalScoreData = calculateFinalScore(contentScore, reflectionScore);
    
    // í•™ìƒìš© ì¢…í•© ë ˆí¬íŠ¸ ëª¨ë‹¬ ìƒì„±
    const modalHTML = `
        <div class="modal-overlay" id="studentReportModal">
            <div class="modal-content student-report-modal">
                <div class="modal-header">
                    <h2>ğŸ“Š íƒêµ¬ í™œë™ ì¢…í•© ë³´ê³ ì„œ</h2>
                    <button class="modal-close" onclick="closeStudentReportModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="final-score-summary">
                        <div class="score-display-large">
                            <div class="final-score">${finalScoreData.finalScore}ì </div>
                            <div class="score-grade ${finalScoreData.grade}">${finalScoreData.grade}</div>
                        </div>
                    </div>
                    
                    <div class="score-breakdown">
                        <h3>ì ìˆ˜ êµ¬ì„±</h3>
                        <div class="score-item">
                            <span>íƒêµ¬ ë‚´ìš© ì ìˆ˜ (70%)</span>
                            <span>${contentScore}ì </span>
                        </div>
                        <div class="score-item">
                            <span>ì˜ë„ ì¼ì¹˜ë„ (20%)</span>
                            <span>${finalScoreData.intentScore}ì </span>
                        </div>
                        <div class="score-item">
                            <span>ì„±ì°° ì ìˆ˜ (10%)</span>
                            <span>${reflectionScore}ì </span>
                        </div>
                    </div>
                    
                    <div class="stage-scores">
                        <h3>ë‹¨ê³„ë³„ ì ìˆ˜</h3>
                        ${generateStageScoreHTML()}
                    </div>
                    
                    <div class="improvement-suggestions">
                        <h3>ê°œì„  ì œì•ˆ</h3>
                        ${generateImprovementSuggestions(finalScoreData)}
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-secondary" onclick="closeStudentReportModal()">ë‹«ê¸°</button>
                    <button class="btn-primary" onclick="startNewInquiry()">ìƒˆ íƒêµ¬ ì‹œì‘</button>
                </div>
            </div>
        </div>
    `;
    
    // ëª¨ë‹¬ì„ bodyì— ì¶”ê°€
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // ëª¨ë‹¬ í‘œì‹œ
    const modal = document.getElementById('studentReportModal');
    if (modal) {
        setTimeout(() => modal.classList.add('show'), 10);
    }
}

// ì „ì—­ í•¨ìˆ˜ë¡œ ë…¸ì¶œ
window.showStudentFinalResult = showStudentFinalResult;

// í•™ìƒ ë ˆí¬íŠ¸ ëª¨ë‹¬ ë‹«ê¸°
function closeStudentReportModal() {
    const modal = document.getElementById('studentReportModal');
    if (modal) {
        modal.classList.remove('show');
        setTimeout(() => modal.remove(), 300);
    }
}

// ë‹¨ê³„ë³„ ì ìˆ˜ HTML ìƒì„±
function generateStageScoreHTML() {
    let html = '<div class="stage-score-list">';
    const stageNames = {
        1: 'ê´€ê³„ë§ºê¸°',
        2: 'ì§‘ì¤‘í•˜ê¸°', 
        3: 'ì¡°ì‚¬í•˜ê¸°',
        4: 'ì •ë¦¬í•˜ê¸°',
        5: 'ì¼ë°˜í™”í•˜ê¸°',
        6: 'ì „ì´í•˜ê¸°'
    };
    
    for (let stage = 1; stage <= 6; stage++) {
        const score = stageScores[stage] || 0;
        const evaluation = stageEvaluations[stage];
        const level = evaluation ? evaluation.level : 'ë¯¸ì™„ë£Œ';
        
        html += `
            <div class="stage-score-item">
                <div class="stage-info">
                    <span class="stage-name">${stage}ë‹¨ê³„: ${stageNames[stage]}</span>
                    <div class="stage-score-display">
                        <span class="score">${score}ì </span>
                        <span class="level ${level}">${level}</span>
                    </div>
                </div>
            </div>
        `;
    }
    
    html += '</div>';
    return html;
}

// ê°œì„  ì œì•ˆ ìƒì„±
function generateImprovementSuggestions(finalScoreData) {
    const suggestions = [];
    
    if (finalScoreData.finalScore >= 90) {
        suggestions.push('ğŸ‰ í›Œë¥­í•œ íƒêµ¬ í™œë™ì´ì—ˆìŠµë‹ˆë‹¤! ê¹Šì´ ìˆëŠ” ì‚¬ê³ ì™€ ì²´ê³„ì ì¸ ì ‘ê·¼ì´ ë‹ë³´ì…ë‹ˆë‹¤.');
        suggestions.push('ğŸ’¡ ë‹¤ë¥¸ ì£¼ì œì—ì„œë„ ì´ëŸ° ìš°ìˆ˜í•œ íƒêµ¬ ëŠ¥ë ¥ì„ ë°œíœ˜í•´ë³´ì„¸ìš”.');
    } else if (finalScoreData.finalScore >= 80) {
        suggestions.push('ğŸ‘ ì „ë°˜ì ìœ¼ë¡œ ì˜ ìˆ˜í–‰ëœ íƒêµ¬ì…ë‹ˆë‹¤.');
        suggestions.push('ğŸ“ˆ ê° ë‹¨ê³„ì—ì„œ ë” êµ¬ì²´ì ì¸ ê·¼ê±°ì™€ ì˜ˆì‹œë¥¼ ì œì‹œí•˜ë©´ ë”ìš± í–¥ìƒë  ê²ƒì…ë‹ˆë‹¤.');
    } else if (finalScoreData.finalScore >= 70) {
        suggestions.push('ğŸ“š ê¸°ë³¸ì ì¸ íƒêµ¬ ê³¼ì •ì€ ì˜ ë”°ë¼í–ˆìŠµë‹ˆë‹¤.');
        suggestions.push('ğŸ” ê° ë‹¨ê³„ì—ì„œ ë” ê¹Šì´ ìˆëŠ” ë¶„ì„ê³¼ ì„±ì°°ì´ í•„ìš”í•©ë‹ˆë‹¤.');
        suggestions.push('ğŸ’­ ìì‹ ì˜ ìƒê°ì„ ë” êµ¬ì²´ì ìœ¼ë¡œ í‘œí˜„í•´ë³´ì„¸ìš”.');
    } else {
        suggestions.push('ğŸ“– íƒêµ¬ì˜ ê¸°ë³¸ ê³¼ì •ì„ ìµíˆëŠ” ê²ƒë¶€í„° ì‹œì‘í•´ë³´ì„¸ìš”.');
        suggestions.push('ğŸ¤ ì„ ìƒë‹˜ì´ë‚˜ ì¹œêµ¬ë“¤ê³¼ í•¨ê»˜ íƒêµ¬ ë°©ë²•ì— ëŒ€í•´ í† ë¡ í•´ë³´ì„¸ìš”.');
        suggestions.push('â° ê° ë‹¨ê³„ì— ì¶©ë¶„í•œ ì‹œê°„ì„ íˆ¬ìí•˜ì—¬ ê¹Šì´ ìˆê²Œ íƒêµ¬í•´ë³´ì„¸ìš”.');
    }
    
    // íŠ¹ë³„ ì œì•ˆ
    if (finalScoreData.intentScore < 70) {
        suggestions.push('ğŸ¯ íƒêµ¬ ì£¼ì œì™€ ì˜ë„ë¥¼ ë” ëª…í™•íˆ í•˜ì—¬ ì¼ê´€ì„± ìˆëŠ” íƒêµ¬ë¥¼ ì§„í–‰í•´ë³´ì„¸ìš”.');
    }
    
    let html = '<ul class="suggestion-list">';
    suggestions.forEach(suggestion => {
        html += `<li>${suggestion}</li>`;
    });
    html += '</ul>';
    
    return html;
}

// ì „ì—­ í•¨ìˆ˜ë¡œ ë…¸ì¶œ
window.closeStudentReportModal = closeStudentReportModal;